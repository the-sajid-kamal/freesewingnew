import {
  root,
  globDir,
  readJsonFile,
  readDirectory,
  readFile,
  writeFile,
} from '../../../scripts/fs.mjs'
import path from 'path'
import matter from 'gray-matter'
import yaml from 'js-yaml'

const prefix = 'packages/react'
const cdir = ['prebuild', 'jsdoc', 'react', 'components']
const components = await globDir(cdir, '**/*.json')

async function processJsdocFile(file) {
  const all = {
    components: {},
    functions: {},
    constants: {},
  }
  const data = await readJsonFile([...cdir, path.basename(file)])
  const family = path.basename(file.slice(0, -5))
  all.components[family] = []
  for (const entry of data) {
    // Is it a component?
    const isComponent = entry.tags
      ? entry.tags.filter((tag) => tag.title === 'component').length > 0
      : false
    // Is it a plain function?
    const isFunction = entry.access === 'public' && Array.isArray(entry.returns) ? true : false
    // Is it a constant?
    const isConstant = !isFunction && entry.access === 'public' ? true : false
    if (isComponent)
      all.components[family].push({
        family,
        name: entry.name,
        file: relativePath(entry.meta.filename, entry.meta.path),
        line: entry.meta.lineno,
        importAs: `import { ${entry.name} } from "${importPath(entry.meta.path)}"`,
        desc: entry.description,
        params: entry.params,
        return: entry.returns,
      })
    else if (isFunction) {
      if (typeof all.functions[family] === 'undefined') all.functions[family] = []
      all.functions[family].push({
        family,
        name: entry.name,
        file: relativePath(entry.meta.filename, entry.meta.path),
        line: entry.meta.lineno,
        importAs: `import { ${entry.name} } from "${importPath(entry.meta.path)}"`,
        desc: entry.description,
        params: entry.params,
        return: entry.returns,
      })
    } else if (isConstant) {
      if (typeof all.constants[family] === 'undefined') all.constants[family] = []
      all.constants[family].push({
        family,
        name: entry.name,
        file: relativePath(entry.meta.filename, entry.meta.path),
        line: entry.meta.lineno,
        importAs: `import { ${entry.name} } from "${importPath(entry.meta.path)}"`,
        desc: entry.description,
      })
    }
  }

  return all
}

async function writeJsdocFiles(data) {
  for (const [family, d] of Object.entries(data.components)) {
    const code = d.map(
      (entry) => `export const jsdoc${entry.name} = ${JSON.stringify(entry)}` + '\n'
    )
    await writeFile(['prebuild', 'jsdoc', `components.${family}.mjs`], code)
  }
  if (data.functions) {
    for (const [family, d] of Object.entries(data.functions)) {
      const code = d.map(
        (entry) => `export const jsdoc${entry.name} = ${JSON.stringify(entry)}` + '\n'
      )
      await writeFile(['prebuild', 'jsdoc', `functions.${family}.mjs`], code)
    }
  }
  if (data.constants) {
    for (const [family, d] of Object.entries(data.constants)) {
      const code = d.map(
        (entry) => `export const jsdoc${entry.name} = ${JSON.stringify(entry)}` + '\n'
      )
      await writeFile(['prebuild', 'jsdoc', `constants.${family}.mjs`], code)
    }
  }
}

function importPath(folder) {
  return `@freesewing/react` + folder.split(prefix).pop()
}

function relativePath(filename, folder) {
  return prefix + folder.split(prefix).pop() + '/' + filename
}

function componentFamily(folder) {
  return folder.split(`${prefix}/components/`).pop()
}

/*
 * Shared header to include in written .js files
 */
export const header = `/*
 *  This file was auto-generated by the prebuild script
 *  Any changes you make to it will be lost on the next (pre)build.
 */
`

/*
 * Ensure key can be used in an import statement
 */
const toImportKey = (key) =>
  key.split('-').join('').split(' ').join('').split('(').join('').split(')').join('')

/*
 * Helper method to generate the jargon imports umbrella file
 */
const ensureJargonImports = async () => {
  const data = []
  const imports = []
  const glob = {
    jargon: './jargon',
  }
  const pages = {}
  for (const section in glob) {
    pages[section] = (await readDirectory(path.resolve(glob[section])))
      .filter((dir) => dir !== 'readme.mdx')
      .map((page) => page.split(`${path.resolve(glob[section])}/`).pop())

    for (const page of pages[section]) {
      const file = path.resolve(`${glob[section]}/${page}`)
      const md = await readFile(file)
      const fm = matter(md)
      const key = fm.data.title
      const ikey = toImportKey(key)
      imports.push(
        `import ${ikey}, { frontMatter as ${ikey}Fm } from '@site${glob[section].slice(1)}/${page}'`
      )
      data.push(
        `  "${key.split('-').join(' ').toLowerCase()}": { ` +
          `title: "${fm.data?.title ? fm.data.title : key.toUpperCase()}", ` +
          `aliases: ${fm.data?.aliases ? JSON.stringify(fm.data.aliases) : '[]'}, ` +
          `content: ${ikey} }`
      )
    }
  }

  await writeFile(
    path.resolve('./prebuild/jargon.js'),
    header + imports.join('\n') + '\n\n' + 'export default {' + '\n' + data.join(',\n') + '\n}\n'
  )
}

/*
 * Helper method to generate the terminology imports umbrella file
 */
const ensureTerminologyImports = async () => {
  const data = []
  const glob = {
    api: './docs/reference/api',
    attributes: './docs/reference/api/attributes',
    defs: './docs/reference/api/defs',
    design: './docs/reference/api/design',
    part: './docs/reference/api/part',
    path: './docs/reference/api/path',
    pattern: './docs/reference/api/pattern',
    point: './docs/reference/api/point',
    snippet: './docs/reference/api/snippet',
    stack: './docs/reference/api/stack',
    store: './docs/reference/api/store',
    svg: './docs/reference/api/svg',
    utils: './docs/reference/api/utils',
  }
  const pages = {}
  for (const section in glob) {
    pages[section] = (await readDirectory(path.resolve(glob[section])))
      .filter((dir) => dir !== 'readme.mdx')
      .map((page) => page.split(`${path.resolve(glob[section])}/`).pop())

    for (const page of pages[section]) {
      const file = path.resolve(`${glob[section]}/${page}/readme.mdx`)
      const md = await readFile(file)
      const fm = matter(md)
      const key = page
      const trigger = section === 'api' ? page : `${section}.${page}`.toLowerCase()
      data.push(
        `  "${trigger}": {` +
          `title: "${fm.data.title}", ` +
          `aliases: ${fm.data.aliases ? JSON.stringify(fm.data.aliases) : '[]'}, ` +
          `url: "${glob[section].slice(6)}/${key}/" }`
      )
    }
  }

  await writeFile(
    path.resolve('./prebuild/terminology.js'),
    header + 'export default {' + '\n' + data.join(',\n') + '\n}\n'
  )
}

for (const file of components) {
  const data = await processJsdocFile(file)
  await writeJsdocFiles(data)
}

ensureJargonImports()
ensureTerminologyImports()
